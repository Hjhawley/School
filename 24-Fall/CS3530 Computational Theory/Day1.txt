Computational Theory
Course Overview:

    This course covers the theory of computation, focusing on finite-state automata, pushdown automata, Turing machines, and equivalent formalisms.
    Complexity theory is also introduced.

By the end of the course, students will be able to:
    Compare the capabilities of various computational models and formulate new models for researching new classes of problems.
    Analyze formal systems with mathematical rigor using appropriate formal notation.
    Investigate computational problems and categorize their algorithmic complexity.
    Appraise and justify the limits of computational models and the real-world systems that rely on them.

Key Concepts:
    Categories of Problems:
        Easier to compute
        Harder to compute
    Goal:
        Assess the computability of a given problem by comparing it to other problems. This has practical implications for determining whether a problem is solvable.
    Pseudocode:
        This semester, pseudocode will be written on paper, not real code.
        Consider how to modularize your code.
    Set Theory:
        Set theory will be heavily utilized throughout the course.

Assignments and Exams:
    Assignments and exams will be typeset using LaTeX. You will need to create a free account at Overleaf if you don’t already have one.

* * * * * * * * * * * * * * * * * * * *

intro to formal systems and computation
what are the fundamental capabilities and limitations of computers?
what is a computation?
"processing of information based on an algorithm (a finite set of operations or rules)"
i.e. arithmetic, babbage wheels, ruler & comapass geometry instructions, digital computers, cells and DNA, the internet and other distributed systems
for our purposes, our precide definition of a computation is: "processing information by unlimited application of a finite set of operations or rules"

"this must be hard because i cant do it"
"this method seems right because its worked on every case i tried"
"it ran once" / "it didnt run once"
These are NOT proofs

we use formal mathematical language and we try to be as precise as we can. we are PROVING theorems
positive - can be computed
negative - cannot be computed

generality
technology independent
abstraction: ignore inessential details

alphabet - a finite (but arbitrarily large) collection of symbols to work with: letters, digits, made up characters, etc
strings - a finite (but arbitrarily large) concatenation of alphabet symbols, where order matters. ex: qaz, abbab. Epsilon (ε) indicates an empty string (length 0)
inputs and outputs of computations are strings - we focus on DISCRETE computations
computational problem or "task" - usually a yes/no question that has infinitely many instances.
    examples - parity: given a string x, does it have an even number of a's? majority: given a string x, does it have more a's than b's?
problems are defined extentionally. a problem is: the set of all instances of the question to which their answer is positive, the set of all question-answer pairs

<'Does "aabaaba" have an even number of a's?', 'No'>   <--- a question-answer pair
if we are using the set {a, b}, how many questions are associated with this parity problem? Infinite! we can always add more characters to the string.
But the answer is always either 'Yes' or 'No' and it can be solved programmatically.

whatever can be computed can be written down.
a language is any set of strings
"solving a yes/no computational problem" <-> "determining if a string is in a given language"
so, all strings in which there is an even number of a's is in that language.
the language is all the "correct" answers. in the case of the parity problem, there is an infinite set of strings in that language.
examples of languages: all words in the american heritage dictionary, all strings with an even number of a's, all syntactically correct C programs (counting 'space' and 'newline' as characters)