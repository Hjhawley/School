Course Overview:

    The course focuses on the theory of computation, including finite-state automata, pushdown automata, Turing machines, and complexity theory.
    By the end of the course, students will be able to compare computational models, analyze formal systems, investigate computational problems, and justify the limits of computational models.

Key Concepts:

    Categories of Problems: Differentiating between problems that are easier or harder to compute.
    Goal: Assess the computability of a problem by comparing it to others, which has practical implications for solvability.
    Pseudocode: Will be used in assignments, emphasizing modularization.
    Set Theory: Will be heavily used throughout the course.

Assignments and Exams:

    Assignments and exams will be typeset using LaTeX on Overleaf, with homework due frequently.

Fundamental Questions:

    What are the capabilities and limitations of computers?
    What constitutes a computation?

Definition of Computation:

    The processing of information based on a finite set of operations or rules, applied without limit.

Common Misconceptions:

    Difficulty in solving a problem does not imply it's inherently hard.
    A method's success on a few cases does not prove correctness.
    A single run (success or failure) doesn't prove the correctness of a method.

Proofs:

    Formal mathematical language and precision are used in proofs, with positive results showing computability and negative results indicating non-computability.

Generality in Computation:

    Computation is technology-independent, with abstraction focusing on essential details.

Key Terms:

    Alphabet: A finite set of symbols used in computations.
    Strings: Ordered sequences of symbols from an alphabet, with Îµ denoting the empty string.
    Inputs and Outputs: In discrete computations, both inputs and outputs are strings.
    Computational Problem: Typically a yes/no question with infinite instances (e.g., parity problem, majority problem).
    Language: A set of strings. Solving a computational problem is equivalent to determining if a string belongs to a language.

Examples of Languages:

    All words in a dictionary.
    All strings with an even number of 'a's.
    All syntactically correct C programs.