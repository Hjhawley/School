What is a Context-Free Grammar (CFG)?

A CFG is a set of rules used to describe how strings in a language can be generated. Think of it as a recipe or set of instructions for creating strings. These instructions can produce more complex patterns than regular languages because they allow nested structures, like matching parentheses, which regular languages cannot handle.

Components of a CFG:
- V: A set of variables (also called non-terminals), which are placeholders that can be replaced by other variables or terminal symbols. They are like “abstract parts” of a string you’re building.
- Σ: The alphabet or terminals, which are the actual symbols that appear in the strings of the language. These are the final characters in the generated strings (like a, b, or 0, 1).
  - Important: V and Σ are disjoint, meaning they don’t overlap. Variables are different from terminal symbols.
- R: A set of rules that describe how to replace variables with other variables or terminals. These rules are written as A → w, where A is a variable, and w is a string made of terminals and/or variables.
- S: The start variable, which is where the process of generating a string begins. It's the "entry point" for building strings.

Example CFG:
For example, the CFG G = ({S}, {a, b}, {S → aSb, S → ε}, S):
- V = {S} (the only variable is S).
- Σ = {a, b} (the alphabet consists of a and b).
- R = {S → aSb, S → ε} (two rules: one replaces S with aSb, the other replaces S with ε (the empty string)).
- S is the start symbol.

This CFG generates strings like:
- ε (empty string),
- ab,
- aabb,
- aaabbb, etc.

It builds strings where the number of a's and b's are equal, with all a's coming before the b's.

Derivations:
- Yields (α ⇒ β): This means α can be turned into β in one step using a rule.
  - For example, using S → aSb, S ⇒ aSb.
- Derives (α ⇒∗ β): This means there is a sequence of steps that transforms α into β.
  - For example, S ⇒∗ aaabb, after applying the rule S → aSb repeatedly.

Example CFG: 
CFG G₁:
Rules:
- A → 0A1
- A → B
- B → #

Strings generated by this CFG: 
- The starting point A can be replaced by 0A1, then you can keep repeating this to get strings like 00A11, and eventually replace A with B, which gives 0B1, and then B → #, resulting in strings like:
  - #,
  - 0#1,
  - 00#11,
  - 000#111, etc.
  
So, the language generated by this CFG is L(G₁) = { 0^n # 1^n ∣ n ≥ 0 }, which means strings that have an equal number of 0's and 1's with a # in the middle.

Parse Trees:
- A parse tree is a tree-like diagram that shows how a string is derived from a CFG. The root of the tree is the start symbol, and each step of the derivation (applying rules) branches down to show how the string is built.

For example, for the string "000#111", the parse tree shows:
1. A → 0A1
2. A → 0A1
3. A → B
4. B → #

Each branch shows how the rules are applied to build the string.